- name: shipping configurations
  hosts: shipping
  become: yes

  tasks:
  - name: Install Maven 
    ansible.builtin.command: dnf install maven -y
      

  - name: creating the system shipping roboshop
    ansible.builtin.user: 
      name: roboshop
      system: true #system user 
      home: /app #optionally setting home
      shell: /sbin/nologin
      comment: roboshop system user


  - name: delete app directory    # Why are we deleting the directory? If we are running the playbook again, that means there might be code changes, right? If the code already exists, Ansible will skip the task when we run the playbook. So is that why we are deleting it?
    ansible.builtin.file:
      path: /app
      state: absent

  - name: create app directory
    ansible.builtin.file:
      path: /app
      state: directory

  - name: Delete the shipping zip file #Why are we deleting the zip file? If we are running the playbook again, that means there might be code changes, right? If the code already exists, Ansible will skip the task when we run the playbook. So is that why we are deleting it?
    ansible.builtin.file: 
      path: /tmp/shipping.zip
      state: absent

  - name: Downloading the shipping zip file
    ansible.builtin.get_url: 
      url: https://roboshop-artifacts.s3.amazonaws.com/shipping-v3.zip 
      dest: /tmp/shipping.zip

  - name: Unzip the code
    ansible.builtin.unarchive:
      src: /tmp/shipping.zip
      dest: /app
      remote_src: yes #What does remote_src mean here? The shipping code is not on the Ansible control node â€” it is already downloaded on the target server using the get_url command. So why do we need to mention remote_src: yes? If we remove it, we get an error.

  - name: Install the dependencies
    ansible.builtin.command: mvn clean package 
    args:
      chdir: "/app" 

  - name: moving and renaming files
    ansible.builtin.command: mv target/shipping-1.0.jar shipping.jar 
      
  - name: copy the shipping service
    ansible.builtin.template:        #We use the template module because it understands variables. It searches for the variable placeholders and replaces them with actual values. Otherwise, Ansible will treat them as plain text, and we may get errors. 
      src: shipping.service
      dest: /etc/systemd/system/shipping.service


  - name: Start, enable & daemon-reload shipping service
    ansible.builtin.systemd:
      name: shipping
      daemon_reload: yes
      state: restarted      #why we are restaring if its running it will restart 
      enabled: yes
      


  

  
  
  